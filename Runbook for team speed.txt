Runbook for Advanced Chatbot Messaging Flow

1. User Sends Message
User initiates conversation by sending a message to the chat frontend.

2. Message Forwarding
Chat frontend forwards message with session_id to backend.

3. Session End Check
Backend checks for end_conversation intent via NLU service.
If detected, backend sends final goodbye message.
Session ID is deleted/invalidated in Redis (session ended explicitly by user).

4. Query Relevance Classification
Backend calls the Relevance Classifier to check if the query is airline-related.
If irrelevant:
Frontend displays clarifying prompt.
Waits for new user input.
If relevant:
Continue processing.

5. Conversation State Management
Backend retrieves current session state from Redis.
Updates session state by extracting new intents and entities from user message (with NLU).
Sets updated state back in Redis with a 10-minute TTL.
If session key expires, Redis deletes the key implicitly ending the session.

6. Action Execution

If intent requires transactional action:
Backend routes request to Transactional Agent.
Transactional Agent calls relevant airline APIs and returns JSON data.
If intent requires informational action:
Backend routes request to Informational Agent (RAG).

Informational Agent:
Sends vectorized user query to Vector DB.
Fetches relevant policy text chunks.
Returns informational text.
Backend aggregates results from all active agents.

7. Response Streaming
Backend makes a STREAMING request to LLM Service with combined context from agents.
LLM Service streams tokens back to backend.
Backend forwards tokens to frontend in a loop.
Frontend renders tokens as text in real time.

8. Clarification and Next Steps
If information is missing or unclear:
Backend sends clarifying questions via frontend (e.g., "What is your PNR?").
Frontend waits for new input to continue the conversation.

Additional Notes:
Session management relies heavily on Redis with a TTL to manage conversation lifespan.
Relevance classification prevents handling out-of-scope queries efficiently.
Parallel transactional and informational agents enable versatile responses.
Real-time token streaming enriches user experience with responsive answers.
All external API calls and agent results should be logged for auditing.
This runbook outlines operational steps, service interactions, data handling, and flow decisions in this multi-component chatbot architecture. It can serve as a guide for administrators, developers, or support teams maintaining the system.

